---
import { globby } from 'globby';
import matter from 'gray-matter';
import { marked } from 'marked';
import fs from 'node:fs';
import path from 'node:path';
import Layout from '../layouts/Layout.astro';
import { spawnSync } from 'node:child_process';
interface TOCItem {
  depth: number;
  text: string;
  slug: string;
}



export async function getStaticPaths() {
  const userRoot = process.env.HEY_DOC_USER_ROOT || '';
  const heydocIndexPath = path.resolve(process.cwd() || 'index.md');

  let defaultIndexContent = '';
  let defaultIndexData = {};

  try {
    const fileContent = fs.readFileSync(heydocIndexPath, 'utf-8');
    const parsed = matter(fileContent);
    defaultIndexContent = parsed.content;
    defaultIndexData = parsed.data;
  } catch (error) {
    console.warn(`Warning: could not read HeyDoc's default index.md. Using empty content.'`);
  }

  const paths = await globby(['**/*.md', '!node_modules', '!dist-docs'], {
    cwd: userRoot,
    absolute: true,
  });

   function getGitMetadata(filePath: string, userRoot: string){
  try {
    const relativePath = path.relative(userRoot, filePath);
    // Run: git log -5 --pretty="format:%ci|%cn|%h|%s" path/to/file
    // %ci = Committer date (ISO 8601)
    // %cn = Committer name
    // %h  = Short hash
    // %s = Subject (commit message)
    const result = spawnSync('git', ['log', '-5', '--pretty=format:%ci|%cn|%h|%s', relativePath], { cwd: userRoot, encoding: 'utf-8' });
    if (result.error || !result.stdout) {
      return []; // Not a git repo or file not committed yet
    }

    const lines = result.stdout.trim().split('\n');
    const commits = lines.map(line => {
      const [dateString, author, hash, message] = line.split('|');
      return {
        lastModifiedDate: new Date(dateString),
        author,
        hash,
        message,
        isFirst:false,
      };
    });

    if (commits.length > 1) {
      const firstResult = spawnSync('git', ['log', '--reverse', '-1', '--pretty=format:%ci|%cn|%h|%s', relativePath], { cwd: userRoot, encoding: 'utf-8' });
      if (firstResult.stdout) {
        const [dateString, author, hash, message] = firstResult.stdout.trim().split('|');
        const firstCommit = {
          lastModifiedDate: new Date(dateString),
          author,
          hash,
          message,
          isFirst: true,
        };
        // Avoid duplicate if first commit is already in the last 5
        if (!commits.some(c => c.hash === firstCommit.hash)) {
          commits.push(firstCommit);
        }
      }
    }

    return commits;
  } catch (error) {
    console.error(`Error in getGitMetadata: ${error}`);
    return [];
  }
}

  const allDocs = paths.map((filePath) => {
    const fileContent = fs.readFileSync(filePath, 'utf-8');
    const { data } = matter(fileContent);

    let relativePath = path.relative(userRoot, filePath);
    let slug: string | undefined = relativePath
      .split(path.sep)
      .join('/')
      .replace(/\.md$/, '')
      .replace(/\/index$/, '');

    if (slug === 'index') slug = undefined;

    const gitInfo = getGitMetadata(filePath, userRoot);

    return {
      title: data.title || slug || 'Untitled',
      href: `/docs${slug ? `/${slug}` : ''}`,
      commits: gitInfo
    };
  });

  console.log(`Discovered ${paths.length} documentation files.`);

 

  const slugify = (text: string) => {
    return text
      .toString()
      .toLowerCase()
      .replace(/\s+/g, '-')
      .replace(/[^\w\-]+/g, '')
      .replace(/\-\-+/g, '-')
      .replace(/^-+/, '')
      .replace(/-+$/, '');
  };

  const results = await Promise.all(
    paths.map(async (filePath) => {
      try {
        const fileContent = fs.readFileSync(filePath, 'utf-8');
        const { data, content } = matter(fileContent);

        let relativePath = path.relative(userRoot, filePath);
        let slug: string | undefined = relativePath.replace(/\.md$/, '').replace(/\/index$/, '');

        const tableOfContents: TOCItem[] = [];
        const slugCount: Record<string, number> = {};
        const renderer = new marked.Renderer();

        // Custom heading renderer for TOC
        renderer.heading = function ({ text, depth }) {
          let slug = slugify(text);
          if (slugCount[slug]) {
            slugCount[slug]++;
            slug += `-${slugCount[slug]}`;
          } else {
            slugCount[slug] = 1;
          }
          // Only include headings up to depth 2
          if(depth > 2) {return ''; } 
          
          tableOfContents.push({ text, depth, slug });
          return `<h${depth} id="${slug}">${text}</h${depth}>`;
        };

        // Enhanced marked options
        const markedOptions = {
          renderer,
          gfm: true, // GitHub Flavored Markdown
          breaks: true, // Convert \n to <br>
          mangle: false, // Don't escape autolinked emails
          pedantic: false, // Don't use original markdown.pl quirks
        };

        if (slug === 'index') slug = undefined;
        console.log(`Mapping: ${relativePath} -> Slug: ${slug}`);
        const htmlContent = await marked.parse(content, markedOptions);

        const gitInfo = getGitMetadata(filePath, userRoot);
        
        return {
          params: { slug },
          props: {
            frontmatter: data,
            htmlContent,
            allDocs,
            tableOfContents,
            commits: gitInfo
          },
        };
      } catch (error) {
        console.error(`âŒ Failed to read file: ${filePath}: ${error}`);
        return null;
      }
    }),
  );

  const validResults = results.filter((res) => res !== null);
  const hasIndex = validResults.some((res) => res.params.slug === undefined);

  if (!hasIndex) {
    const tableOfContents: TOCItem[] = [];
    const slugCount: Record<string, number> = {};
    const renderer = new marked.Renderer();
    renderer.heading = function ({ text, depth }) {
      let slug = slugify(text);
      if (slugCount[slug]) {
        slugCount[slug]++;
        slug += `-${slugCount[slug]}`;
      } else {
        slugCount[slug] = 1;
      }
      tableOfContents.push({ text, depth, slug });
      return `<h${depth} id="${slug}">${text}</h${depth}>`;
    };

    const htmlContent = await marked.parse(defaultIndexContent, {
      renderer,
      gfm: true,
      breaks: true,
    });

    validResults.push({
      params: { slug: undefined },
      props: {
        frontmatter: defaultIndexData,
        htmlContent,
        allDocs,
        tableOfContents,
        
        commits: []
      },
    });
  }
  return validResults;
}

const { frontmatter, htmlContent, allDocs, tableOfContents, commits } = Astro.props;
const isIndex = Astro.params.slug === undefined;
---

<Layout sidebarLinks={allDocs} tableOfContents={tableOfContents} title={frontmatter.title || 'Documentation'}>
  <div class="p-4 overflow-y-scroll flex justify-center items-start flex-col w-full">
    <!-- Markdown content with proper styling -->
     {!isIndex &&<details class="mb-4">
       <summary class="text-sm text-gray-600 cursor-pointer list-none">
         {commits && commits.length > 0 ? (
           <>Last Updated: {new Date(commits[0].lastModifiedDate).toLocaleDateString('en-US', { dateStyle: 'medium' })} by {commits[0].author} ({commits[0].hash.slice(0,7)}) - {commits[0].message}</>
         ) : (
           'No commit history available'
         )}
       </summary>
       {commits && commits.length > 1 && (
         <div class="mt-2 text-sm text-gray-500 pl-4 border-l-2 border-gray-300">
           {commits.slice(1).map((c, index) => (
             <p class="mb-1">
               <strong>{c.hash.slice(0,7)}</strong>: {new Date(c.lastModifiedDate).toLocaleDateString('en-US', { dateStyle: 'short' })} by {c.author} - {c.message}{c.isFirst ? ' (First Commit)' : ''}
             </p>
           ))}
         </div>
       )}
     </details>}
    <article class="markdown-content" set:html={htmlContent} />

   {isIndex ? <h1 class="text-xl">Recently Updated Docs</h1>
    <div class="p-4 bg-[#f9f9f9]">
      <ul>
        {
          [...allDocs].sort((a, b) => {
            const dateA = a.commits[0]?.lastModifiedDate || new Date(0);
            const dateB = b.commits[0]?.lastModifiedDate || new Date(0);
            return dateB.getTime() - dateA.getTime(); // Descending: most recent first
          }).slice(0,10).map((doc) => (
            <li>
              <a href={doc.href}>{doc.title}</a>
            </li>
          ))
        }
      </ul>
    </div>:
    <div class="w-full flex justify-center items-center text-xl p-10 bg-[#f9f9f9]">
      <a href="/docs">Back to Documentation Home</a>
    </div>
    }
  </div>

  <script>
    // TOC scroll highlight
    document.addEventListener('DOMContentLoaded', () => {
      const tocLinks = document.querySelectorAll('.toc-link');
      const headings = document.querySelectorAll('h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]');

      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              // Remove active from all
              tocLinks.forEach((link) => link.classList.remove('text-slate-400'));
              // Add to current
              const activeLink = document.querySelector(`.toc-link[href="#${entry.target.id}"]`);
              if (activeLink) {
                activeLink.classList.add('text-slate-400');
              }
            }
          });
        },
        { rootMargin: '-80px 0px -80% 0px' } // Adjust for header
      );

      headings.forEach((heading) => observer.observe(heading));
    });
  </script>

  <style is:global>
    /* Markdown Content Styling */
    .markdown-content {
      max-width: 100%;
      line-height: 1.6;
      color: #333;
    }

    /* Headings */
    .markdown-content h1 {
      font-size: 2.5em;
      font-weight: bold;
      margin-top: 0.67em;
      margin-bottom: 0.67em;
      line-height: 1.2;
      border-bottom: 1px solid #eaecef;
      padding-bottom: 0.3em;
    }

    .markdown-content h2 {
      font-size: 2em;
      font-weight: bold;
      margin-top: 0.83em;
      margin-bottom: 0.83em;
      line-height: 1.25;
      border-bottom: 1px solid #eaecef;
      padding-bottom: 0.3em;
    }

    .markdown-content h3 {
      font-size: 1.5em;
      font-weight: bold;
      margin-top: 1em;
      margin-bottom: 1em;
      line-height: 1.3;
    }

    .markdown-content h4 {
      font-size: 1.25em;
      font-weight: bold;
      margin-top: 1.33em;
      margin-bottom: 1.33em;
    }

    .markdown-content h5 {
      font-size: 1em;
      font-weight: bold;
      margin-top: 1.67em;
      margin-bottom: 1.67em;
    }

    .markdown-content h6 {
      font-size: 0.875em;
      font-weight: bold;
      margin-top: 2.33em;
      margin-bottom: 2.33em;
      color: #6a737d;
    }

    /* Paragraphs */
    .markdown-content p {
      margin-top: 0;
      margin-bottom: 16px;
    }

    /* Code blocks */
    .markdown-content pre {
      background-color: #f6f8fa;
      border-radius: 6px;
      padding: 16px;
      overflow: auto;
      font-size: 85%;
      line-height: 1.45;
      margin-bottom: 16px;
    }

    .markdown-content code {
      background-color: rgba(175, 184, 193, 0.2);
      padding: 0.2em 0.4em;
      border-radius: 6px;
      font-size: 85%;
      font-family:
        ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Consolas, 'Liberation Mono', monospace;
    }

    .markdown-content pre code {
      background-color: transparent;
      padding: 0;
      border-radius: 0;
      font-size: 100%;
    }

    /* Lists */
    .markdown-content ul,
    .markdown-content ol {
      padding-left: 2em;
      margin-top: 0;
      margin-bottom: 16px;
    }

    .markdown-content li {
      margin-top: 0.25em;
    }

    .markdown-content li > p {
      margin-top: 16px;
    }

    /* Links */
    .markdown-content a {
      color: #0969da;
      text-decoration: none;
    }

    .markdown-content a:hover {
      text-decoration: underline;
    }

    /* Blockquotes */
    .markdown-content blockquote {
      padding: 0 1em;
      color: #57606a;
      border-left: 0.25em solid #d0d7de;
      margin: 0 0 16px 0;
    }

    .markdown-content blockquote > :first-child {
      margin-top: 0;
    }

    .markdown-content blockquote > :last-child {
      margin-bottom: 0;
    }

    /* Horizontal rules */
    .markdown-content hr {
      height: 0.25em;
      padding: 0;
      margin: 24px 0;
      background-color: #d0d7de;
      border: 0;
    }

    /* Tables */
    .markdown-content table {
      border-spacing: 0;
      border-collapse: collapse;
      margin-bottom: 16px;
      width: 100%;
      overflow: auto;
    }

    .markdown-content table th,
    .markdown-content table td {
      padding: 6px 13px;
      border: 1px solid #d0d7de;
    }

    .markdown-content table th {
      font-weight: 600;
      background-color: #f6f8fa;
    }

    .markdown-content table tr {
      background-color: #ffffff;
      border-top: 1px solid #d0d7de;
    }

    .markdown-content table tr:nth-child(2n) {
      background-color: #f6f8fa;
    }

    /* Images */
    .markdown-content img {
      max-width: 100%;
      box-sizing: content-box;
      background-color: #ffffff;
    }

    /* Task lists */
    .markdown-content input[type='checkbox'] {
      margin-right: 0.5em;
    }

    /* Strong and emphasis */
    .markdown-content strong {
      font-weight: 600;
    }

    .markdown-content em {
      font-style: italic;
    }

    /* Details expand animation */
    details[open] > div {
      animation: slideDown 0.3s ease;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
  </style>
</Layout>
